package DP;

/**
 *  动态规划组成部分：
 *  一、确定状态：
 *         设f[i][j]为机器人有多少种方式从左上角走到(i,j)
 *         即f[i][j]:存储的是走到(i,j),有多少种方式
 *  二、转移方程：
 *         对任意一个格子(i,j):f[i][j]=f[i-1][j]+f[i][j-1]
 *         f[i][j]:机器人有多少种方式走到(i,j)
 *         f[i-1][j]:机器人有多少种方式走到(i-1,j)
 *         f[i][j-1]:机器人有多少种方式走到(i,j-1) 
 *  三、初始条件和边界情况
 *         初始条件：f[0][0]=1
 *         边界情况：i=0或j=0，则前一步只能有一个方向过来-->f[i][j]=1 
 *  四、计算顺序
 * 
 *  给定m行n列的网格，有一个机器人从左上角(0,0)出发，每一步可以向下或者向右走一步
 *  有多少种不同的方式走到右下角(重点是走的方式，不是步数)
 * 
 *  如果机器人有x种方式从左上角走到(m-2,n-1),
 *  有y种方式左上角走到(m-1,n-2),
 *  则机器人有x+yz种方式走到(m-1,n-1)
 *  (重点是走的方式，不是步数)
 * 
 */

 public class UniquePath {
    public int uniquePath(int m,int n) {

        int[][]f=new int[m][n];

        int i,j;

        for(i=0;i<m;i++) {
            for(j=0;j<n;j++) {
                if(i==0 || j==0) {
                    f[i][j]=1;
                } else {
                    f[i][j]=f[i-1][j]+f[i][j-1];
                }
            }
        }

        return f[m-1][n-1];
    }

    public static void main(String[] args) {
        
    }
 }