package DP;

/**
 * 
 * 有一段由A-Z组成的字母串信息被加密成数字串
 * 加密方式为：A->1,B->2,...,Z->26
 * 给定加密后的数字串s[0...N-1]，问有多少种方式解密成字母串
 * 注:s是字符串形式
 * 
 * 确定状态：
 *      解密数字串即划分成若干段数字，每段数字对应一个字母
 *      最后一步（最后一段）：对应一个字母A-Z
 *      这个字母加密时变成1,2，。。。，或26
 *      
 *      假设字母串s的最后一位数字是8，倒数第二个是1
 *      当确定最后一个字母由是8代表时，有100中组合方式
 *      当确定最后一个字母由18代表时，有50种组合方式
 *      那么最后有100+50中组合方式
 *      （不理解，记住。。。）
 * 
 * 转移方程：
 *  f[i]=f[i](s[i-1]对应一个字母)+f[i-2](s[i-2]s[i-1]对应一个字母)
 * 
 * 初始条件：f[0]=1,即空串有一种解密方式
 * 
 * 边界情况：如果i=1,只看最后一个数字
 */

 public class DecodeWays {
     public int numDecodings(String string) {

        char[] s=string.toCharArray();
        int n=s.length;
        if(n==0) {
            return 0;
        }

        int[] f=new int[n+1];
        int i;
        f[0]=1;
        for(i=1;i<=n;i++) {
            f[i]=0;

            //最后一个数字
            int t=s[i-1]-'0';
            if(t>=1 && t<=9) {
                f[i] += f[i-1];
            }

            if(i>=2) {
                //最后两个数字
                t=(s[i-2]-'0')*10+(s[i-1]-'0');
                if(t>=10 && t<=26) {
                    f[i] += f[i-2];
                }
            }
        }

        return f[n];
     }

     
     public static void main(String[] args) {
         
     }

 }






 